(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.client = global.client || {}, global.client.js = factory()));
})(this, (function () { 'use strict';

  /**
   *
   * container: 这是一个DOM节点，它是React应用挂载的地方。所有的React组件都会被渲染为这个容器的子节点。
   *
   * current: 这是一个指向当前正在显示的Fiber树的指针。当React需要进行更新时，它会创建一个新的Fiber树，并且在完成更新后，将current指针指向新的Fiber树。
   *
   * finishedWork: 这是一个指向已经完成但还没有提交的工作的指针。当React完成一次更新后，它会将完成的工作存储在finishedWork中，等待合适的时机进行提交（即更新DOM）。
   */
  class FiberRootNode {
      container;
      current;
      finishedWork;
      //初始化FiberRootNode,绑定一下current
      constructor(container, hostRootFiber) {
          //current绑定Fiber树的根节点
          this.current = hostRootFiber;
          this.container = container;
          hostRootFiber.stateNode = this;
          this.finishedWork = null;
      }
  }

  //Fiber的组件类型
  const FunctionComponent = 0;
  const ClassComponent = 1;
  //Root of a host tree. Could be nested inside another node.
  const HostRoot = 2;
  const HostText = 3;
  //  A DOM element.
  const HostComponent = 4;

  //集中副作用的定义，采用2进制表示
  //缺少就补
  /**
   * 在JavaScript和TypeScript中，|= 是一个位运算赋值操作符，它执行按位或（bitwise OR）操作并赋值。

   * 这是它的工作方式：

   * 它首先将左操作数和右操作数转换为32位二进制数。
   * 然后，它对这两个二进制数执行按位或操作。按位或操作的规则是，如果两个相应的二进制位中至少有一个为1，则结果为1，否则为0。
   * 最后，它将结果赋值给左操作数。
   * 例如，假设fiber.flags的值为2（在二进制中为10），并且Placement的值为1（在二进制中为01）。那么fiber.flags |= Placement;将fiber.flags的值更新为3（在二进制中为11）。
   *
   *
   * 例如fiber.flags == NoFlags 现在执行 fiber.flags |= Placement 为 0x00000011
   * 现在有一个更新操作 fiber.flags |= Update 为 0x00000111
   * 处理时读位即可
   *
   */
  const NoFlags = /*                      */ 0b00000001;
  const Placement = /*                    */ 0b00000010;
  const Update = /*                       */ 0b00000100;
  const Deletion = /*                     */ 0b00010000;
  const MutationMask = Placement | Update | Deletion;

  //定义fiber结构
  class FiberNode {
      // 对于 FunctionComponent，指函数本身()=>{}这种,对于ClassComponent，指class，对于HostComponent，指DOM节点tagName
      type;
      // Fiber对应组件的类型 Function/Class/Host...
      tag;
      pendingProps; //更改的属性
      key;
      stateNode; //真实dom
      ref;
      //节点定义，详细参考Fiber树
      return;
      child;
      sibling;
      index; //标注兄弟元素中排名多少
      //update的标注
      subtreeFlags;
      flags;
      memorizedProps;
      memorizedState; // memorizedState有很多情况
      alternate;
      //TODO: 后期再实现
      //参考https://kasong.gitee.io/just-react/state/update.html#updatequeue
      updateQueue;
      //优先级相关,后期标注为Lane
      lanes;
      //构造时有type props key
      constructor(tag, pendingProps, key) {
          this.tag = tag;
          this.key = key;
          this.stateNode = null;
          this.type = null;
          //节点构成
          this.return = null;
          this.sibling = null;
          this.child = null;
          this.index = 0;
          this.ref = null;
          //工作单元
          this.pendingProps = pendingProps;
          this.memorizedProps = null;
          //对应的current，互相链接
          this.alternate = null;
          //副作用，确定本次更新该干什么
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
          this.lanes = null;
      }
  }
  //Fiber的双渲染机制，要么mount 要么update
  //PINK: 先复制current，再根据pendingProps修改
  //创建工作树，然后交给render和commit，分别制造子节点和进行更新字段
  //请参考https://kasong.gitee.io/just-react/process/doubleBuffer.html#%E4%BB%80%E4%B9%88%E6%98%AF-%E5%8F%8C%E7%BC%93%E5%AD%98
  function createWorkInProgress(current, pendingProps) {
      // PINK: 通过current.alternate判断
      // 过程: 1. 首次渲染时，只有一个RootFiber ,只能手工制造一个RootFiber，并使用alternate进行根绑定
      // 然后: 2. 更新时，由于上次的alternate没有解绑，代表至少完成过mount，即现在是update阶段，判断alternate是否存在，存在的话
      //         第二次构建的 workInprogress 的 rootFiber 复用部分 上一次的current, 并初始化一些操作
      //         例如副作用清空，传入新的props准备diff，然后交给render 走 DFS 构建剩下的 Fiber
      //
      //获取是否alternate，如果有update没有为mount首屏渲染
      let wip = current.alternate;
      if (wip == null) {
          wip = new FiberNode(current.tag, pendingProps, current.key);
          // wip.flags = null
      }
      else {
          //update 初始化一下wip
          wip.pendingProps = pendingProps;
          wip.flags = NoFlags;
          wip.subtreeFlags = NoFlags;
      }
      //相当于把current复制给wip了
      wip.type = current.type;
      wip.key = current.key;
      wip.stateNode = current.stateNode;
      wip.ref = current.ref;
      wip.memorizedProps = current.memorizedProps;
      wip.child = current.child;
      wip.index = current.index;
      //初始化后，重新绑定，上次的alternate被废除
      wip.alternate = current;
      current.alternate = wip;
      return wip;
  }

  function createUpdate(action) {
      return {
          action,
      };
  }
  function createUpdateQueue() {
      return {
          share: {
              pending: null,
          },
      };
  }
  function enqueueUpdate(update, updateQueue) {
      updateQueue.share.pending = update;
  }
  /**
   * process 处理方面的函数
   * 用于处理更新队列
   * 调用一些更新方法例如this.setState 会创造一个Update ，会根据UpdateQueue循环处理，对baseState进行reduce处理
   * 更新可能包括函数调用或值更新，因此会有两个，一般来说process会有循环套在外面的
   */
  function processUpdateQueue(baseState, pendingUpdate) {
      /*ReturnType 可以帮助获取特定函数的返回类型
       *function sayHello(){return {foo:"foo"}}
       *ReturnType<sayHello>
       */
      const result = {
          memorized: baseState,
      };
      if (pendingUpdate != null) {
          const action = pendingUpdate.action;
          if (action instanceof Function) {
              result.memorized = action(baseState);
          }
          else {
              result.memorized = action;
          }
      }
      return result;
  }

  //由于reactElement $$typeof很特殊，因此定义为一个symbol类型作为独一无法的标识，防止ReactElement被滥用
  //Symbol会产生一个唯一的值，symbol.for()会在全局产生一个唯一的值
  const supportSymbol = typeof Symbol === "function" && Symbol.for;
  const REACT_ELEMENT_TYPE = supportSymbol
      ? Symbol.for("react-element")
      : 0xeac7;

  //reconcilerChildren的工厂，毕竟逻辑相同，而且构建子fiber有区别
  //shouldTrackEffects会决定是update还是mount
  //TODO: 根据current进行复用渲染，可以使用diff算法
  function ChildReconciler(shouldTrackEffects) {
      //闭包策略
      //目前 child可能的type ReactElement    string | number
      //渲染组件
      function reconcilerSingleElement(returnFiber, currentFirstChild, element) {
          const fiber = createFiberWithReactElement(element);
          fiber.return = returnFiber; //绑定好
          return fiber;
      }
      //渲染纯文字
      function reconcilerSingleTextNode(returnFiber, currentFirstChild, textContent) {
          const fiber = new FiberNode(HostText, {
              content: textContent,
          }, null);
          fiber.return = returnFiber;
          return fiber;
      }
      //渲染多child
      function reconcilerMultiChildren(returnFiber, currentFiber, childArray) {
          //PS:  child有可能多种类型,这里也需要进行判断对不同的child进行处理
          const fiber = createFiberWithReactElement(childArray[0]);
          let siblingFiber = fiber;
          fiber.return = returnFiber;
          for (let index = 1; index < childArray.length; index++) {
              placeSingleChild(fiber);
              siblingFiber.sibling = createFiberWithReactElement(childArray[index]);
              siblingFiber = siblingFiber.sibling;
          }
          return fiber;
      }
      // plugin
      //mount时只会在rootFiber存在Placement effectTag
      function placeSingleChild(fiber) {
          //TODO :处理完后的plugin
          if (shouldTrackEffects && fiber.alternate == null) {
              fiber.flags |= Placement;
          }
          return fiber;
      }
      return function reconcileChildFibers(workInProgress, currentFiber, childElement) {
          //TODO 其他类型的实现
          console.log(childElement);
          if (typeof childElement == "object" &&
              childElement != null &&
              Array.isArray(childElement) == false) {
              console.log(childElement.$$typeof);
              if (childElement.$$typeof == REACT_ELEMENT_TYPE) {
                  return placeSingleChild(reconcilerSingleElement(workInProgress, currentFiber, childElement));
              }
              else {
                  {
                      console.error("未实现的reconciler类型");
                      return null;
                  }
              }
          }
          if (typeof childElement == "string" || typeof childElement == "number") {
              return placeSingleChild(reconcilerSingleTextNode(workInProgress, currentFiber, childElement));
          }
          if (typeof childElement == "object" && Array.isArray(childElement)) {
              if (childElement.length == 0) {
                  return null;
              }
              return placeSingleChild(reconcilerMultiChildren(workInProgress, currentFiber, childElement));
          }
          {
              console.error("未知的childElement类型", childElement);
          }
          return null;
      };
  }
  const mountReconcilerChild = ChildReconciler(false);
  const updateReconcilerChild = ChildReconciler(true);

  //Diff算法会比较ReactElement来构造本次的fiber，并打上flag，具体的应该在completework执行
  //begin的所有阶段请参考https://kasong.gitee.io/just-react/process/beginWork.html#effecttag
  const beginWork = (wip) => {
      //初始化等
      //1.判断是否可以复用，待实现
      //2.根据tag区分要如何处理
      switch (wip.tag) {
          case FunctionComponent:
              return updateClassComponent();
          case ClassComponent:
              return updateFunctionComponent();
          case HostRoot:
              return updateHostRoot(wip);
          case HostComponent:
              return updateHostComponent(wip);
          default:
              {
                  console.error("beginWork: 没有与之匹配的tag");
              }
              break;
      }
      //最后要返回子节点
      console.log(wip.child);
      return null;
  };
  /**
   * 在React的Fiber架构中，updateQueue主要用于存储组件状态的更新。当你在一个类组件或函数组件中调用setState或forceUpdate时，
   * React会创建一个更新（Update）并将它添加到updateQueue中。
   * 然而，HostComponent是代表真实DOM元素的Fiber节点，它们不具有自己的状态。
   * 因此，HostComponent节点没有updateQueue，也就不需要处理updateQueue
   */
  function updateFunctionComponent(wip) {
      return null;
  }
  function updateClassComponent(wip) {
      return null;
  }
  function updateHostRoot(wip) {
      //采用reducer策略
      const memorizeState = wip.memorizedState;
      //每一个更新都涉及到Element的更新
      const update = wip.updateQueue;
      const pending = update.share.pending;
      update.share.pending = null;
      const { memorized: updateState } = processUpdateQueue(memorizeState, pending);
      wip.memorizedState = updateState;
      //获取下一个Element，准备转化为Fiber
      const nextChild = wip.memorizedState;
      reconcilerChildren(wip, nextChild);
      //准备更新
      console.log(wip.child);
      // return wip.child;
  }
  function updateHostComponent(wip) {
      //区分好！！！别弄混
      //wip.child 是子fiber 他的子ReactElement在props上面的child , jsx转化的时候就这么处理
      const nextProps = wip.pendingProps;
      const nextChild = nextProps.children;
      reconcilerChildren(wip, nextChild);
      return wip.child;
  }
  //构建child 子fiber节点
  function reconcilerChildren(wip, children) {
      const current = wip.alternate;
      //把ReactElement转化为Fiber并绑定到wip上
      if (current != null) {
          //update机制
          wip.child = updateReconcilerChild(wip, current.child, children);
      }
      else {
          // mount机制
          wip.child = mountReconcilerChild(wip, null, children);
      }
  }

  const appendInitialChild = (parent, instance) => {
      //直接添加为子child
      parent.appendChild(instance);
  };
  const appendChildToContainer = appendInitialChild;

  let nextEffect = null;
  const commitMutationEffects = (finishedWork) => {
      nextEffect = finishedWork;
      while (nextEffect !== null) {
          //找根节点,由于冒泡flags分subtreeFlags和自己的flags
          if (nextEffect.child !== null &&
              (nextEffect.subtreeFlags & MutationMask) != NoFlags) {
              nextEffect = nextEffect.child;
          }
          else {
              //找到了根发生突变的节点,由于可能是child或者sibling的flag，因此一并处理
              while (nextEffect != null) {
                  commitMutationEffectsOnFiber(nextEffect);
                  if (nextEffect.sibling != null) {
                      nextEffect = nextEffect.sibling;
                  }
                  else {
                      nextEffect = nextEffect.return;
                  }
              }
          }
      }
  };
  const commitMutationEffectsOnFiber = (finishedFiber) => {
      finishedFiber.flags;
      //根据Type进行不同的flags处理,相当于流水线式处理
      if ((finishedFiber.flags & Placement) != NoFlags) {
          handlePlacementFlag(finishedFiber);
          //对Placement的二进制取反执行按位与，Placement位会变成0
          finishedFiber.flags &= ~Placement;
      }
      return;
  };
  //处理placementFlag
  const handlePlacementFlag = (finishedFiber) => {
      {
          console.log("handle placement flag");
      }
      //获取父container，将节点放进container
      const hostParent = getHostParent(finishedFiber);
      if (hostParent != null) {
          appendPlacementNodeInContainer(finishedFiber, hostParent);
      }
  };
  const getHostParent = (fiber) => {
      let parent = fiber.return;
      //找根HostComponent
      while (parent) {
          if (parent.tag == HostComponent) {
              return parent.stateNode;
          }
          if (parent.tag == HostRoot) {
              return parent.stateNode.container;
          }
          parent = parent.return;
      }
      {
          console.error("Commit 未找到parentHost");
      }
      return null;
  };
  //这个节点下面所有的关于host的添加到他parentContainer中
  const appendPlacementNodeInContainer = (finishedFiber, parent) => {
      //TODO: 递归处理，因为冒泡，所以需要递归添加
      const tag = finishedFiber.tag;
      if (tag == HostComponent || tag === HostText) {
          appendChildToContainer(parent, finishedFiber.stateNode);
          return;
      }
      const child = finishedFiber.child;
      if (child != null) {
          appendPlacementNodeInContainer(child, parent);
          let sibling = child.sibling;
          while (sibling !== null) {
              appendPlacementNodeInContainer(sibling, parent);
              sibling = sibling.sibling;
          }
      }
  };

  //请参考https://kasong.gitee.io/just-react/process/fiber.html#fiber%E7%9A%84%E7%BB%93%E6%9E%84
  //React 采用DFS来遍历构成Fiber树，
  //reconclier的render阶段会根据fiberNode构建子Fiber
  //beginWork为DFS的递阶段 ，completework为DFS的归阶段
  //全局变量，所有函数都能用
  let workInProgress;
  const prepareFreshStack = (root) => {
      //用于将当前DFS遍历的位置赋值给workInProgess指针
      workInProgress = createWorkInProgress(root.current, null);
  };
  const createFiberWithReactElement = (reactElement) => {
      const { type, props, key, ref } = reactElement;
      const fiber = new FiberNode(HostComponent, props, key);
      if (typeof type === "string") {
          fiber.tag = HostComponent;
      }
      else if (typeof type === "function") {
          fiber.tag = FunctionComponent;
      }
      else {
          {
              console.error("未知定义的type类型", reactElement);
          }
      }
      fiber.type = type;
      fiber.key = key;
      fiber.ref = ref;
      return fiber;
  };
  //Schedule模块
  function ScheduleUpdateOnFiber(updateNode) {
      //调度更新的一些处理
      const root = markUpdateFromFiberToRoot(updateNode);
      renderRoot(root);
  }
  function markUpdateFromFiberToRoot(fiber) {
      let node = fiber;
      let parent = node.return;
      while (parent != null) {
          node = parent;
          parent = node.return;
      }
      //如果是null的话代表到达RootFiberNode了
      if (node.tag == HostRoot) {
          return node.stateNode;
      }
      else {
          //Error: 存在问题
          console.error("未找到RootFiberNode");
          return null;
      }
  }
  //入口
  const renderRoot = (fiberRoot) => {
      //一些预先处理,创建workInProgress
      prepareFreshStack(fiberRoot);
      do {
          try {
              workLoop();
              break;
          }
          catch (e) {
              //异常处理一下
              {
                  console.warn("render Current: workLoop interupt", e);
              }
          }
      } while (true);
      //处理完后给与finnishWork，准备好渲染
      //fiberRoot.current.alternate 为本次构建的wip
      const finishedWork = fiberRoot.current.alternate;
      fiberRoot.finishedWork = finishedWork;
      //commit阶段
      commitRoot(fiberRoot);
  };
  //DFS入口
  function workLoop() {
      //DFS结束条件为指针为空结束
      while (workInProgress != null) {
          performUnitOfWork(workInProgress);
      }
  }
  function performUnitOfWork(fiber) {
      console.log(fiber);
      //DFS分为三步，先递，再归
      //next 子节点， fiber当前节点
      //next 会一直往下找 直到为null ，然后网上弹，如果有sibling，workInprogress为子节点，又走递归
      //设计思想：1.先一直往下走
      const next = beginWork(fiber);
      //Q:为什么要这样设计？
      fiber.memorizedProps = fiber.pendingProps;
      if (next == null) {
          //走到顶了往上走
          // completeUnitWork(fiber);
          workInProgress = null;
          return;
      }
      else {
          workInProgress = next;
      }
  }
  //commit阶段
  function commitRoot(fiberRoot) {
      //fiberRoot.finishWork 为 render阶段的wip
      const finishedWork = fiberRoot.finishedWork;
      if (finishedWork == null) {
          return;
      }
      {
          console.warn("开始commit阶段");
      }
      /**
       * commit 三个阶段
       * before mutation
       * mutation
       * layout
       */
      //before mutation之前 完成一些属性的提取和重置，
      fiberRoot.finishedWork == null;
      //判断副作用,由于flags冒泡，所有flags已经冒泡到顶部
      finishedWork.subtreeFlags !== NoFlags;
      const isHasFlags = finishedWork.flags !== NoFlags;
      if (isHasFlags && isHasFlags) {
          commitMutationEffects(finishedWork);
      }
      else {
          //layout,切换到wip
          fiberRoot.current = finishedWork;
      }
  }
  //https://react.iamkasong.com/renderer/beforeMutation.html#%E6%A6%82%E8%A7%88

  //调度更新入口函数，供react-dom使用！！！，其它接口请不要暴露
  const createContainer = (container) => {
      //Root 初始化
      const fiberRoot = new FiberNode(HostRoot, {}, null);
      const root = new FiberRootNode(container, fiberRoot);
      //处理更新
      fiberRoot.updateQueue = createUpdateQueue();
      return root;
  };
  const updateContainer = (element, root) => {
      //触发schedule
      const rootCurrent = root.current;
      const update = createUpdate(element);
      enqueueUpdate(update, rootCurrent.updateQueue);
      ScheduleUpdateOnFiber(rootCurrent);
  };

  const createRoot = (container) => {
      console.log(container, "createRoot");
      const root = createContainer(container);
      return {
          render(element) {
              //触发更新
              updateContainer(element, root);
          },
      };
  };

  const reactDOM = {
      createRoot: createRoot,
  };

  return reactDOM;

}));
