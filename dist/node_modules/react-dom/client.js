(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
  typeof define === 'function' && define.amd ? define(['react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.client = factory(global.react));
})(this, (function (react) { 'use strict';

  /**
   *
   * container: 这是一个DOM节点，它是React应用挂载的地方。所有的React组件都会被渲染为这个容器的子节点。
   *
   * current: 这是一个指向当前正在显示的Fiber树的指针。当React需要进行更新时，它会创建一个新的Fiber树，并且在完成更新后，将current指针指向新的Fiber树。
   *
   * finishedWork: 这是一个指向已经完成但还没有提交的工作的指针。当React完成一次更新后，它会将完成的工作存储在finishedWork中，等待合适的时机进行提交（即更新DOM）。
   */
  class FiberRootNode {
      container;
      current;
      finishedWork;
      //初始化FiberRootNode,绑定一下current
      constructor(container, hostRootFiber) {
          //current绑定Fiber树的根节点
          this.current = hostRootFiber;
          this.container = container;
          hostRootFiber.stateNode = this;
          this.finishedWork = null;
      }
  }

  //Fiber的组件类型
  const FunctionComponent = 0;
  const ClassComponent = 1;
  //Root of a host tree. Could be nested inside another node.
  const HostRoot = 2;
  const HostText = 3;
  //  A DOM element.
  const HostComponent = 4;

  //集中副作用的定义，采用2进制表示
  //缺少就补
  /**
   * 在JavaScript和TypeScript中，|= 是一个位运算赋值操作符，它执行按位或（bitwise OR）操作并赋值。

   * 这是它的工作方式：

   * 它首先将左操作数和右操作数转换为32位二进制数。
   * 然后，它对这两个二进制数执行按位或操作。按位或操作的规则是，如果两个相应的二进制位中至少有一个为1，则结果为1，否则为0。
   * 最后，它将结果赋值给左操作数。
   * 例如，假设fiber.flags的值为2（在二进制中为10），并且Placement的值为1（在二进制中为01）。那么fiber.flags |= Placement;将fiber.flags的值更新为3（在二进制中为11）。
   *
   *
   * 例如fiber.flags == NoFlags 现在执行 fiber.flags |= Placement 为 0x00000011
   * 现在有一个更新操作 fiber.flags |= Update 为 0x00000111
   * 处理时读位即可
   *
   */
  const NoFlags = /*                      */ 0b00000001;
  const Placement = /*                    */ 0b00000010;
  const Update = /*                       */ 0b00000100;
  const Deletion = /*                     */ 0b00010000;
  const MutationMask = Placement | Update | Deletion;

  //定义fiber结构
  class FiberNode {
      // 对于 FunctionComponent，指函数本身()=>{}这种,对于ClassComponent，指class，对于HostComponent，指DOM节点tagName
      type;
      // Fiber对应组件的类型 Function/Class/Host...
      tag;
      pendingProps; //更改的属性
      key;
      stateNode; //真实dom
      ref;
      //节点定义，详细参考Fiber树
      return;
      child;
      sibling;
      index; //标注兄弟元素中排名多少
      //update的标注
      subtreeFlags;
      flags;
      memorizedProps;
      memorizedState; // memorizedState有很多情况
      alternate;
      //TODO: 后期再实现
      //参考https://kasong.gitee.io/just-react/state/update.html#updatequeue
      updateQueue;
      //优先级相关,后期标注为Lane
      lanes;
      //构造时有type props key
      constructor(tag, pendingProps, key) {
          this.tag = tag;
          this.key = key;
          this.stateNode = null;
          this.type = null;
          //节点构成
          this.return = null;
          this.sibling = null;
          this.child = null;
          this.index = 0;
          this.ref = null;
          //工作单元
          this.pendingProps = pendingProps;
          this.memorizedProps = null;
          //对应的current，互相链接
          this.alternate = null;
          //副作用，确定本次更新该干什么
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
          this.lanes = null;
      }
  }
  //Fiber的双渲染机制，要么mount 要么update
  //PINK: 先复制current，再根据pendingProps修改
  //创建工作树，然后交给render和commit，分别制造子节点和进行更新字段
  //请参考https://kasong.gitee.io/just-react/process/doubleBuffer.html#%E4%BB%80%E4%B9%88%E6%98%AF-%E5%8F%8C%E7%BC%93%E5%AD%98
  function createWorkInProgress(current, pendingProps) {
      // PINK: 通过current.alternate判断
      // 过程: 1. 首次渲染时，只有一个RootFiber ,只能手工制造一个RootFiber，并使用alternate进行根绑定
      // 然后: 2. 更新时，由于上次的alternate没有解绑，代表至少完成过mount，即现在是update阶段，判断alternate是否存在，存在的话
      //         第二次构建的 workInprogress 的 rootFiber 复用部分 上一次的current, 并初始化一些操作
      //         例如副作用清空，传入新的props准备diff，然后交给render 走 DFS 构建剩下的 Fiber
      //
      //获取是否alternate，如果有update没有为mount首屏渲染
      let wip = current.alternate;
      if (wip == null) {
          wip = new FiberNode(current.tag, pendingProps, current.key);
          wip.stateNode = current.stateNode;
          //初始化绑定
          wip.alternate = current;
          current.alternate = wip;
      }
      else {
          //update 初始化一下wip
          wip.pendingProps = pendingProps;
          wip.flags = NoFlags;
          wip.subtreeFlags = NoFlags;
      }
      //相当于把current复制给wip了
      wip.type = current.type;
      wip.key = current.key;
      wip.stateNode = current.stateNode;
      wip.ref = current.ref;
      wip.memorizedProps = current.memorizedProps;
      wip.child = current.child;
      wip.index = current.index;
      wip.updateQueue = current.updateQueue;
      return wip;
  }
  const createFiberWithReactElement = (reactElement) => {
      const { type, props, key, ref } = reactElement;
      const fiber = new FiberNode(HostComponent, props, key);
      if (typeof type === "string") {
          fiber.tag = HostComponent;
      }
      else if (typeof type === "function") {
          fiber.tag = FunctionComponent;
      }
      else {
          {
              console.error("未知定义的type类型", reactElement);
          }
      }
      fiber.type = type;
      fiber.key = key;
      fiber.ref = ref;
      return fiber;
  };

  function createUpdate(action) {
      return {
          action,
      };
  }
  function createUpdateQueue() {
      return {
          share: {
              pending: null,
          },
          dispatch: null,
      };
  }
  function enqueueUpdate(update, updateQueue) {
      updateQueue.share.pending = update;
  }
  /**
   * process 处理方面的函数
   * 用于处理更新队列
   * 调用一些更新方法例如this.setState 会创造一个Update ，会根据UpdateQueue循环处理，对baseState进行reduce处理
   * 更新可能包括函数调用或值更新，因此会有两个，一般来说process会有循环套在外面的
   */
  function processUpdateQueue(baseState, pendingUpdate) {
      /*ReturnType 可以帮助获取特定函数的返回类型
       *function sayHello(){return {foo:"foo"}}
       *ReturnType<sayHello>
       */
      const result = {
          memorized: baseState,
      };
      if (pendingUpdate != null) {
          const action = pendingUpdate.action;
          if (action instanceof Function) {
              result.memorized = action(baseState);
          }
          else {
              result.memorized = action;
          }
      }
      return result;
  }

  //由于reactElement $$typeof很特殊，因此定义为一个symbol类型作为独一无法的标识，防止ReactElement被滥用
  //Symbol会产生一个唯一的值，symbol.for()会在全局产生一个唯一的值
  const supportSymbol = typeof Symbol === "function" && Symbol.for;
  const REACT_ELEMENT_TYPE = supportSymbol
      ? Symbol.for("react-element")
      : 0xeac7;

  //reconcilerChildren的工厂，毕竟逻辑相同，而且构建子fiber有区别
  //shouldTrackEffects会决定是update还是mount
  //TODO: 根据current进行复用渲染，可以使用diff算法
  function ChildReconciler(shouldTrackEffects) {
      //闭包策略
      //目前 child可能的type ReactElement    string | number | function
      //ps 对于函数式组件 ，type为()=>{}，child需要通过运行type才能获取，jsx规定所致
      //因此创造fiber时没有child，需要创造functionComponent时会运行type获取child
      //渲染组件
      function reconcilerSingleElement(returnFiber, currentFirstChild, element) {
          const fiber = createFiberWithReactElement(element);
          fiber.return = returnFiber; //绑定好
          return fiber;
      }
      //渲染纯文字
      function reconcilerSingleTextNode(returnFiber, currentFirstChild, textContent) {
          const fiber = new FiberNode(HostText, {
              content: textContent,
          }, null);
          fiber.return = returnFiber;
          return fiber;
      }
      //渲染多child
      function reconcilerMultiChildren(returnFiber, currentFiber, childArray) {
          //TODO:  child有可能多种类型,这里也需要进行判断对不同的child进行处理
          //例如
          /**
           * <div>aaa<span>bbb</span></div> aaa为String类型，<span></span>为ElementType
           */
          const fiber = createFiberWithReactElement(childArray[0]);
          let siblingFiber = fiber;
          fiber.return = returnFiber;
          placeSingleChild(fiber);
          for (let index = 1; index < childArray.length; index++) {
              siblingFiber.sibling = createFiberWithReactElement(childArray[index]);
              siblingFiber.sibling.return = returnFiber;
              placeSingleChild(siblingFiber.sibling);
              siblingFiber = siblingFiber.sibling;
          }
          return fiber;
      }
      // plugin
      // mount时只会在rootFiber存在Placement effectTag
      function placeSingleChild(fiber) {
          //TODO :处理完后的plugin
          // console.log(fiber.flags, fiber.type);
          if (shouldTrackEffects && fiber.alternate == null) {
              fiber.flags |= Placement;
          }
          return fiber;
      }
      return function reconcileChildFibers(workInProgress, currentFiber, childElement) {
          //TODO 其他类型的实现
          console.log("childElement", childElement);
          if (typeof childElement == "object" &&
              childElement != null &&
              Array.isArray(childElement) == false) {
              if (childElement.$$typeof == REACT_ELEMENT_TYPE) {
                  return placeSingleChild(reconcilerSingleElement(workInProgress, currentFiber, childElement));
              }
              else {
                  {
                      console.error("未实现的reconciler类型");
                      return null;
                  }
              }
          }
          if (typeof childElement == "string" || typeof childElement == "number") {
              return placeSingleChild(reconcilerSingleTextNode(workInProgress, currentFiber, childElement));
          }
          if (typeof childElement == "object" && Array.isArray(childElement)) {
              if (childElement.length == 0) {
                  return null;
              }
              return reconcilerMultiChildren(workInProgress, currentFiber, childElement);
          }
          {
              console.error("未知的childElement类型", childElement);
          }
          return null;
      };
  }
  const mountReconcilerChild = ChildReconciler(false);
  const updateReconcilerChild = ChildReconciler(true);

  const internals = react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  let currentlyRenderingFiber = null;
  let workInProgressHook = null;
  console.log(internals);
  const currentDispatcher = internals.currentDispatcher;
  //hook的调度机制 https://react.iamkasong.com/hooks/prepare.html
  /**
   * 简单来说就useState和dispatch(setState)两个使用时刻，我们将useState称为声明阶段，dispatch称为调度阶段
   * 声明阶段:
   *  mount: 根据代码从上到下创建hook并使用next链接起来，同时赋予初始initState，并返回，所有hook均在
   *         Fiber.memorizeState上面
   *  update: 根据调度发生在hook结构体上的update更新initState，并返回更新后的updateState
   * 调度阶段:
   *  给hook结构体上的updateQueue添加新的update，启动再次渲染，在新的声明阶段会计算出对应的update并重新赋值。同时
   *  打上对应的flags
   */
  //begin阶段处理
  const renderWithHooks = (wip) => {
      //hook 处理
      currentlyRenderingFiber = wip;
      //当前wip重置，准备处理后返回
      wip.memorizedState = null;
      const current = wip.alternate;
      if (current != null) ;
      else {
          //绑定好对应的mountHook执行逻辑
          currentDispatcher.current = HookDispatcherOnMount;
      }
      //Function Component的type为()=>{},可以直接把props传递，会返回对应的ReactElement
      const FunctionComponent = wip.type;
      const props = wip.pendingProps;
      console.log(currentDispatcher);
      const children = FunctionComponent(props);
      //函数组件及时清理，保证hook调用是在函数式组件调用
      currentlyRenderingFiber = null;
      return children;
  };
  //声明阶段
  const mountState = (initState) => {
      const hook = mountWorkInProgressHook();
      let memoizedState;
      if (initState instanceof Function) {
          memoizedState = initState();
      }
      else {
          memoizedState = initState;
      }
      const queue = createUpdateQueue();
      hook.updateQueue = queue;
      hook.memoizedState = memoizedState;
      //@ts-ignore
      //dispatch会触发schedule开启新一轮渲染，同时也会讲更新添加进队列
      const dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [memoizedState, dispatch];
  };
  //调度阶段
  function dispatchSetState(fiber, updateQueue, action) {
      const update = createUpdate(action);
      enqueueUpdate(update, updateQueue);
      ScheduleUpdateOnFiber(fiber);
  }
  //mount hook执行逻辑
  const HookDispatcherOnMount = {
      useState: mountState,
  };
  //函数式组件hook的依次调用被设为next来进行连接，保证更新的顺序
  const mountWorkInProgressHook = () => {
      const hook = {
          memoizedState: null,
          updateQueue: null,
          next: null,
      };
      if (workInProgressHook == null) {
          //mount
          if (currentlyRenderingFiber == null) {
              throw Error("请在函数式组件调用hook");
          }
          workInProgressHook = hook;
          currentlyRenderingFiber.memorizedState = workInProgressHook;
      }
      else {
          workInProgressHook.next = hook;
          workInProgressHook = hook;
      }
      return workInProgressHook;
  };

  //Diff算法会比较ReactElement来构造本次的fiber，并打上flag，具体的应该在completework执行
  //begin的所有阶段请参考https://kasong.gitee.io/just-react/process/beginWork.html#effecttag
  const beginWork = (wip) => {
      //最后要返回子节点
      //初始化等
      //1.判断是否可以复用，待实现
      //2.根据tag区分要如何处理
      console.log("begin", wip);
      switch (wip.tag) {
          case FunctionComponent:
              return updateFunctionComponent(wip);
          case ClassComponent:
              return updateClassComponent();
          case HostRoot:
              return updateHostRoot(wip);
          case HostComponent:
              return updateHostComponent(wip);
          case HostText:
              //到底部了，准备commit往上走
              return null;
          default:
              {
                  console.error("beginWork: 没有与之匹配的tag");
              }
              break;
      }
      return null;
  };
  /**
   * 在React的Fiber架构中，updateQueue主要用于存储组件状态的更新。当你在一个类组件或函数组件中调用setState或forceUpdate时，
   * React会创建一个更新（Update）并将它添加到updateQueue中。
   * 然而，HostComponent是代表真实DOM元素的Fiber节点，它们不具有自己的状态。
   * 因此，HostComponent节点没有updateQueue，也就不需要处理updateQueue
   */
  function updateFunctionComponent(wip) {
      const children = renderWithHooks(wip);
      reconcilerChildren(wip, children);
      return wip.child;
  }
  function updateClassComponent(wip) {
      return null;
  }
  function updateHostRoot(wip) {
      //采用reducer策略
      const memorizeState = wip.memorizedState;
      //每一个更新都涉及到Element的更新
      const update = wip.updateQueue;
      console.log("update", update);
      const pending = update.share.pending;
      update.share.pending = null;
      const { memorized: updateState } = processUpdateQueue(memorizeState, pending);
      wip.memorizedState = updateState;
      //获取下一个Element，准备转化为Fiber
      const nextChild = wip.memorizedState;
      reconcilerChildren(wip, nextChild);
      //准备更新
      return wip.child;
  }
  function updateHostComponent(wip) {
      //区分好！！！别弄混
      //wip.child 是子fiber 他的子ReactElement在props上面的child , jsx转化的时候就这么处理
      const nextProps = wip.pendingProps;
      const nextChild = nextProps.children;
      reconcilerChildren(wip, nextChild);
      return wip.child;
  }
  //构建child 子fiber节点
  function reconcilerChildren(wip, children) {
      const current = wip.alternate;
      //把ReactElement转化为Fiber并绑定到wip上
      if (current != null) {
          //update机制
          wip.child = updateReconcilerChild(wip, current.child, children);
      }
      else {
          // mount机制
          wip.child = mountReconcilerChild(wip, null, children);
      }
  }

  const createInstance = (type, ...args) => {
      const element = document.createElement(type);
      //待处理props
      return element;
  };
  const appendInitialChild = (parent, instance) => {
      //直接添加为子child
      parent.appendChild(instance);
  };
  const createTextInstance = (content) => {
      const textElement = document.createTextNode(content);
      console.log(textElement);
      return textElement;
  };
  const appendChildToContainer = appendInitialChild;

  //completeWork的设计理念请参考https://kasong.gitee.io/just-react/process/completeWork.html
  //completeWork需要完成
  const completeWork = (wip) => {
      //归阶段，完成一些事情
      const newProps = wip.pendingProps;
      const current = wip.alternate;
      switch (wip.tag) {
          case FunctionComponent:
              bubbleProperties(wip);
              return;
          case ClassComponent:
          case HostText:
              // Host Text 绝对的最底部，不存在child，不需要appendAllChildren来
              // 将节点冒泡
              if (current != null && wip.stateNode != null) ;
              else {
                  const instance = createTextInstance(newProps.content);
                  wip.stateNode = instance;
              }
              bubbleProperties(wip);
              return;
          case HostRoot:
              bubbleProperties(wip);
              return;
          case HostComponent:
              //判断是否存在dom
              /**
               * wip.stateNode = dom;是将新创建的DOM元素赋值给wip，
               * 而appendInitialChild(dom, wip);是将wip的子节点添加到这个DOM元素上。
               * 这两步操作都是必要的，因为它们分别完成了DOM元素的创建和子元素的添加。
               */
              if (current != null && wip.stateNode != null) ;
              else {
                  //1. 构建dom 一个dom标签和其props就可以构建了，其他的暂时不用，ref也暂时不考虑
                  const instance = createInstance(wip.type, newProps);
                  //2. 将dom 插入到当前的 dom树中
                  appendAllChildren(instance, wip);
                  wip.stateNode = instance;
              }
              //事件冒泡,将子事件的flags冒泡到父组件上
              bubbleProperties(wip);
              return;
          default:
              {
                  console.error("未知的tag类型", wip.tag);
              }
              break;
      }
      return;
  };
  const bubbleProperties = (wip) => {
      let bubbleNode = wip.child;
      let subTreeFlags = NoFlags;
      while (bubbleNode != null) {
          //子孙全部冒泡并全部绑定
          subTreeFlags |= bubbleNode.flags;
          subTreeFlags |= bubbleNode.subtreeFlags;
          bubbleNode.return = wip;
          //子孙节点的flags全部冒泡
          bubbleNode = bubbleNode.sibling;
      }
      wip.subtreeFlags |= subTreeFlags;
  };
  /***
   * 原因就在于completeWork中的appendAllChildren方法。
   * 由于completeWork属于“归”阶段调用的函数，
   * 每次调用appendAllChildren时都会将已生成的子孙DOM节点插入当前生成的DOM节点下。
   * 那么当“归”到rootFiber时，我们已经有一个构建好的离屏DOM树
   */
  //parent当前的DOM节点
  //Study: 这个函数逻辑很优秀
  function appendAllChildren(parent, wip) {
      let node = wip.child;
      while (node != null) {
          //对于 HostComponent 和 HostText 在归过程中stateNode一直更新，因此不需要找其child，因为已经通过归阶段一步步放到
          //顶部节点了
          //而对于子节点非HostComponent就递归往下找，如果找到HostComponent，再冒泡往上走，并每次走的时候都把sibling都处理好return绑定到children的return
          if (node.tag == HostComponent || node.tag == HostText) {
              appendInitialChild(parent, node.stateNode);
          }
          else if (node.child != null) {
              node.child.return = node;
              node = node.child;
              continue;
          }
          if (node === wip) {
              return;
          }
          //对多余的其他兄弟节点进行处理
          while (node.sibling === null) {
              if (node.return == null || node.return == wip) {
                  return;
              }
              node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }

  let nextEffect = null;
  const commitMutationEffects = (finishedWork) => {
      nextEffect = finishedWork;
      //DFS遍历，寻找所有的突变点，和先递后归原理一样
      while (nextEffect !== null) {
          let isSibling = false;
          //找根节点,由于冒泡flags分subtreeFlags和自己的flags
          if (nextEffect.child !== null &&
              (nextEffect.subtreeFlags & MutationMask) != NoFlags) {
              nextEffect = nextEffect.child;
          }
          else {
              //找到了根发生突变的节点,由于可能是child或者sibling的flag，因此一并处理
              //从下到上依次将子statenode绑定给父statenode
              // TODO: 推到根节点退出，hostRoot目前不处理，因为没有
              while (nextEffect != null && !isSibling && nextEffect.tag != HostRoot) {
                  commitMutationEffectsOnFiber(nextEffect);
                  if (nextEffect.sibling != null) {
                      nextEffect = nextEffect.sibling;
                      isSibling = true;
                      console.log("sibling");
                  }
                  else {
                      nextEffect = nextEffect.return;
                  }
              }
              if (nextEffect != null && nextEffect.tag == HostRoot) {
                  nextEffect = null;
              }
          }
      }
  };
  const commitMutationEffectsOnFiber = (finishedFiber) => {
      //根据Type进行不同的flags处理,相当于流水线式处理
      if ((finishedFiber.flags & Placement) != NoFlags) {
          handlePlacementFlag(finishedFiber);
          //对Placement的二进制取反执行按位与，Placement位会变成0
          finishedFiber.flags &= ~Placement;
      }
      return;
  };
  //处理placementFlag
  const handlePlacementFlag = (finishedFiber) => {
      {
          console.log("handle placement flag");
      }
      //获取父container，将节点放进container
      const hostParent = getHostParent(finishedFiber);
      if (hostParent != null) {
          appendPlacementNodeInContainer(finishedFiber, hostParent);
      }
  };
  const getHostParent = (fiber) => {
      let parent = fiber.return;
      //找根HostComponent
      while (parent) {
          if (parent.tag == HostComponent) {
              return parent.stateNode;
          }
          if (parent.tag == HostRoot) {
              return parent.stateNode.container;
          }
          parent = parent.return;
      }
      {
          console.error(fiber);
          console.error("Commit 未找到parentHost");
      }
      return null;
  };
  //这个节点下面所有的关于host的添加到他parentContainer中
  const appendPlacementNodeInContainer = (finishedFiber, parent) => {
      //TODO: 递归处理，因为冒泡，所以需要递归添加
      const tag = finishedFiber.tag;
      if (tag == HostComponent || tag === HostText) {
          appendChildToContainer(parent, finishedFiber.stateNode);
          return;
      }
      const child = finishedFiber.child;
      if (child != null) {
          appendPlacementNodeInContainer(child, parent);
          let sibling = child.sibling;
          while (sibling !== null) {
              appendPlacementNodeInContainer(sibling, parent);
              sibling = sibling.sibling;
          }
      }
  };

  //请参考https://kasong.gitee.io/just-react/process/fiber.html#fiber%E7%9A%84%E7%BB%93%E6%9E%84
  //React 采用DFS来遍历构成Fiber树，
  //reconclier的render阶段会根据fiberNode构建子Fiber
  //beginWork为DFS的递阶段 ，completework为DFS的归阶段
  //全局变量，所有函数都能用
  let workInProgress;
  const prepareFreshStack = (root) => {
      //用于将当前DFS遍历的位置赋值给workInProgess指针
      workInProgress = createWorkInProgress(root.current, null);
  };
  //Schedule模块
  function ScheduleUpdateOnFiber(updateNode) {
      //调度更新的一些处理
      const root = markUpdateFromFiberToRoot(updateNode);
      renderRoot(root);
  }
  function markUpdateFromFiberToRoot(fiber) {
      let node = fiber;
      let parent = node.return;
      while (parent != null) {
          node = parent;
          parent = node.return;
      }
      //如果是null的话代表到达RootFiberNode了
      if (node.tag == HostRoot) {
          return node.stateNode;
      }
      else {
          //Error: 存在问题
          console.error("未找到RootFiberNode");
          return null;
      }
  }
  //入口
  const renderRoot = (fiberRoot) => {
      //一些预先处理,创建workInProgress
      prepareFreshStack(fiberRoot);
      do {
          try {
              workLoop();
              break;
          }
          catch (e) {
              //异常处理一下
              {
                  console.warn("render Current: workLoop interupt", e);
                  return;
              }
          }
      } while (true);
      //处理完后给与finnishWork，准备好渲染
      //fiberRoot.current.alternate 为本次构建的wip
      const finishedWork = fiberRoot.current.alternate;
      fiberRoot.finishedWork = finishedWork;
      //commit阶段
      commitRoot(fiberRoot);
  };
  //DFS入口
  function workLoop() {
      //DFS结束条件为指针为空结束
      while (workInProgress != null) {
          performUnitOfWork(workInProgress);
      }
      return;
  }
  function performUnitOfWork(fiber) {
      //DFS分为三步，先递，再归
      //next 子节点， fiber当前节点
      //next 会一直往下找 直到为null ，然后网上弹，如果有sibling，workInprogress为子节点，又走递归
      //设计思想：1.先一直往下走
      const next = beginWork(fiber);
      //Q:为什么要这样设计？
      fiber.memorizedProps = fiber.pendingProps;
      if (next == null) {
          //走到顶了往上走
          completeUnitWork(fiber);
      }
      else {
          workInProgress = next;
      }
  }
  function completeUnitWork(fiber) {
      //遍历到底会全部反弹，直接循环执行
      //设计思想: 中断条件为遍历到顶，如果有sibling，使用return结束
      let node;
      node = fiber;
      do {
          console.log("complete", node);
          //归阶段想完成的事情,指针同步更改,不需要对wip进行递归，这是处理文件
          completeWork(node);
          if (node.sibling) {
              workInProgress = node.sibling;
              return;
          }
          else {
              node = node.return;
              workInProgress = node;
          }
      } while (node != null);
      //其实为null就已经走出循环了，不需要在定义为null
      workInProgress = null;
  }
  //commit阶段
  function commitRoot(fiberRoot) {
      //fiberRoot.finishWork 为 render阶段的wip
      const finishedWork = fiberRoot.finishedWork;
      console.log(finishedWork);
      if (finishedWork == null) {
          return;
      }
      {
          console.warn("开始commit阶段");
      }
      /**
       * commit 三个阶段
       * before mutation
       * mutation
       * layout
       */
      //before mutation之前 完成一些属性的提取和重置，
      fiberRoot.finishedWork == null;
      //判断副作用,由于flags冒泡，所有flags已经冒泡到顶部
      const isHasSubFlags = finishedWork.subtreeFlags !== NoFlags;
      const isHasFlags = finishedWork.flags !== NoFlags;
      if (isHasFlags || isHasSubFlags) {
          //开启commit的三个阶段
          console.log("进入commit");
          commitMutationEffects(finishedWork);
      }
      else {
          //layout,切换到wip
          fiberRoot.current = finishedWork;
      }
  }
  //https://react.iamkasong.com/renderer/beforeMutation.html#%E6%A6%82%E8%A7%88

  //调度更新入口函数，供react-dom使用！！！，其它接口请不要暴露
  const createContainer = (container) => {
      //Root 初始化
      const fiberRoot = new FiberNode(HostRoot, {}, null);
      const root = new FiberRootNode(container, fiberRoot);
      //处理更新
      fiberRoot.updateQueue = createUpdateQueue();
      return root;
  };
  const updateContainer = (element, root) => {
      //触发schedule
      const rootCurrent = root.current;
      const update = createUpdate(element);
      enqueueUpdate(update, rootCurrent.updateQueue);
      ScheduleUpdateOnFiber(rootCurrent);
  };

  const createRoot = (container) => {
      const root = createContainer(container);
      return {
          render(element) {
              //触发更新
              return updateContainer(element, root);
          },
      };
  };

  const reactDOM = {
      createRoot: createRoot,
  };

  return reactDOM;

}));
