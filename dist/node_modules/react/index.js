(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.index = global.index || {}, global.index.js = factory()));
})(this, (function () { 'use strict';

  //由于reactElement $$typeof很特殊，因此定义为一个symbol类型作为独一无法的标识，防止ReactElement被滥用
  //Symbol会产生一个唯一的值，symbol.for()会在全局产生一个唯一的值
  const supportSymbol = typeof Symbol === "function" && Symbol.for;
  const REACT_ELEMENT_TYPE = supportSymbol
      ? Symbol.for("react-element")
      : 0xeac7;

  //创建ReactElement，具体处理
  const ReactElement = function (type, props, ref, key) {
      return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          props,
          ref,
          key,
          __mark: "yemomo",
      };
  };
  const jsxDEV = (type, config) => {
      let key = null;
      let ref = null;
      const props = {};
      for (const prop in config) {
          const value = config[prop];
          if (prop == "key") {
              if (value != undefined) {
                  key = value + "";
              }
          }
          if (prop == "ref") {
              if (value != undefined) {
                  ref = value;
              }
          }
          if ({}.hasOwnProperty.call(config, prop)) {
              //config中有children 会是config
              props[prop] = value;
          }
      }
      return ReactElement(type, props, ref, key);
  };

  //Fiber的组件类型
  const FunctionComponent = 0;
  //  A DOM element.
  const HostComponent = 4;

  //集中副作用的定义，采用2进制表示
  //缺少就补
  /**
   * 在JavaScript和TypeScript中，|= 是一个位运算赋值操作符，它执行按位或（bitwise OR）操作并赋值。

   * 这是它的工作方式：

   * 它首先将左操作数和右操作数转换为32位二进制数。
   * 然后，它对这两个二进制数执行按位或操作。按位或操作的规则是，如果两个相应的二进制位中至少有一个为1，则结果为1，否则为0。
   * 最后，它将结果赋值给左操作数。
   * 例如，假设fiber.flags的值为2（在二进制中为10），并且Placement的值为1（在二进制中为01）。那么fiber.flags |= Placement;将fiber.flags的值更新为3（在二进制中为11）。
   *
   *
   * 例如fiber.flags == NoFlags 现在执行 fiber.flags |= Placement 为 0x00000011
   * 现在有一个更新操作 fiber.flags |= Update 为 0x00000111
   * 处理时读位即可
   *
   */
  const NoFlags = /*                      */ 0b00000001;

  //定义fiber结构
  class FiberNode {
      // 对于 FunctionComponent，指函数本身()=>{}这种,对于ClassComponent，指class，对于HostComponent，指DOM节点tagName
      type;
      // Fiber对应组件的类型 Function/Class/Host...
      tag;
      pendingProps; //更改的属性
      key;
      stateNode; //真实dom
      ref;
      //节点定义，详细参考Fiber树
      return;
      child;
      sibling;
      index; //标注兄弟元素中排名多少
      //update的标注
      subtreeFlags;
      flags;
      memorizedProps;
      memorizedState; // memorizedState有很多情况
      alternate;
      //TODO: 后期再实现 
      //参考https://kasong.gitee.io/just-react/state/update.html#updatequeue
      updateQueue;
      //优先级相关,后期标注为Lane
      lanes;
      //构造时有type props key
      constructor(tag, pendingProps, key) {
          this.tag = tag;
          this.key = key;
          this.stateNode = null;
          this.type = null;
          //节点构成
          this.return = null;
          this.sibling = null;
          this.child = null;
          this.index = 0;
          this.ref = null;
          //工作单元
          this.pendingProps = pendingProps;
          this.memorizedProps = null;
          //对应的current，互相链接
          this.alternate = null;
          //副作用，确定本次更新该干什么
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
          this.lanes = null;
      }
  }

  //请参考https://kasong.gitee.io/just-react/process/fiber.html#fiber%E7%9A%84%E7%BB%93%E6%9E%84
  //React 采用DFS来遍历构成Fiber树，
  //reconclier的render阶段会根据fiberNode构建子Fiber
  //beginWork为DFS的递阶段 ，completework为DFS的归阶段
  const createFiberWithReactElement = (reactElement) => {
      const { type, props, key, ref } = reactElement;
      const fiber = new FiberNode(HostComponent, props, key);
      if (typeof type === "string") {
          fiber.tag = HostComponent;
      }
      else if (typeof type === "function") {
          fiber.tag = FunctionComponent;
      }
      else {
          {
              console.error("未知定义的type类型", reactElement);
          }
      }
      fiber.type = type;
      fiber.key = key;
      fiber.ref = ref;
      return fiber;
  };

  //打包后成为react包，导出createReactElement 即 React.createReactElement ,
  //babel 会吧jsx 转换 例如<div>aaa</div> 为React.createReactElement("div",{},"aaa")
  //通过我们自定义的方法就可以生成ReactElement
  var index = {
      version: "0.0.0",
      createElement: jsxDEV,
      createFiberWithReactElement
  };

  return index;

}));
