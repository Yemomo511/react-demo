(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.index = global.index || {}, global.index.js = factory()));
})(this, (function () { 'use strict';

  //由于reactElement $$typeof很特殊，因此定义为一个symbol类型作为独一无法的标识，防止ReactElement被滥用
  //Symbol会产生一个唯一的值，symbol.for()会在全局产生一个唯一的值
  const supportSymbol = typeof Symbol === "function" && Symbol.for;
  const REACT_ELEMENT_TYPE = supportSymbol
      ? Symbol.for("react-element")
      : 0xeac7;

  //创建ReactElement，具体处理
  const ReactElement = function (type, props, ref, key) {
      return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          props,
          ref,
          key,
          __mark: "yemomo",
      };
  };
  const jsxDEV = (type, config) => {
      let key = null;
      let ref = null;
      const props = {};
      for (const prop in config) {
          const value = config[prop];
          if (prop == "key") {
              if (value != undefined) {
                  key = value + "";
              }
          }
          if (prop == "ref") {
              if (value != undefined) {
                  ref = value;
              }
          }
          if ({}.hasOwnProperty.call(config, prop)) {
              //config中有children 会是config
              props[prop] = value;
          }
      }
      return ReactElement(type, props, ref, key);
  };

  //Fiber的组件类型
  const FunctionComponent = 0;
  const ClassComponent = 1;
  //Root of a host tree. Could be nested inside another node.
  const HostRoot = 2;
  const HostText = 3;
  //  A DOM element.
  const HostComponent = 4;

  /**
   * process 处理方面的函数
   * 用于处理更新队列
   * 调用一些更新方法例如this.setState 会创造一个Update ，会根据UpdateQueue循环处理，对baseState进行reduce处理
   * 更新可能包括函数调用或值更新，因此会有两个，一般来说process会有循环套在外面的
   */
  function processUpdateQueue(baseState, pendingUpdate) {
      /*ReturnType 可以帮助获取特定函数的返回类型
       *function sayHello(){return {foo:"foo"}}
       *ReturnType<sayHello>
       */
      const result = {
          memorized: baseState,
      };
      if (pendingUpdate != null) {
          const action = pendingUpdate.action;
          if (action instanceof Function) {
              result.memorized = action(baseState);
          }
          else {
              result.memorized = action;
          }
      }
      return result;
  }

  //集中副作用的定义，采用2进制表示
  //缺少就补
  /**
   * 在JavaScript和TypeScript中，|= 是一个位运算赋值操作符，它执行按位或（bitwise OR）操作并赋值。

   * 这是它的工作方式：

   * 它首先将左操作数和右操作数转换为32位二进制数。
   * 然后，它对这两个二进制数执行按位或操作。按位或操作的规则是，如果两个相应的二进制位中至少有一个为1，则结果为1，否则为0。
   * 最后，它将结果赋值给左操作数。
   * 例如，假设fiber.flags的值为2（在二进制中为10），并且Placement的值为1（在二进制中为01）。那么fiber.flags |= Placement;将fiber.flags的值更新为3（在二进制中为11）。
   *
   *
   * 例如fiber.flags == NoFlags 现在执行 fiber.flags |= Placement 为 0x00000011
   * 现在有一个更新操作 fiber.flags |= Update 为 0x00000111
   * 处理时读位即可
   *
   */
  const NoFlags = /*                      */ 0b00000001;
  const Placement = /*                    */ 0b00000010;

  //定义fiber结构
  class FiberNode {
      // 对于 FunctionComponent，指函数本身()=>{}这种,对于ClassComponent，指class，对于HostComponent，指DOM节点tagName
      type;
      // Fiber对应组件的类型 Function/Class/Host...
      tag;
      pendingProps; //更改的属性
      key;
      stateNode; //真实dom
      ref;
      //节点定义，详细参考Fiber树
      return;
      child;
      sibling;
      index; //标注兄弟元素中排名多少
      //update的标注
      subtreeFlags;
      flags;
      memorizedProps;
      memorizedState; // memorizedState有很多情况
      alternate;
      //TODO: 后期再实现
      //参考https://kasong.gitee.io/just-react/state/update.html#updatequeue
      updateQueue;
      //优先级相关,后期标注为Lane
      lanes;
      //构造时有type props key
      constructor(tag, pendingProps, key) {
          this.tag = tag;
          this.key = key;
          this.stateNode = null;
          this.type = null;
          //节点构成
          this.return = null;
          this.sibling = null;
          this.child = null;
          this.index = 0;
          this.ref = null;
          //工作单元
          this.pendingProps = pendingProps;
          this.memorizedProps = null;
          //对应的current，互相链接
          this.alternate = null;
          //副作用，确定本次更新该干什么
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
          this.lanes = null;
      }
  }

  //reconcilerChildren的工厂，毕竟逻辑相同，而且构建子fiber有区别
  //shouldTrackEffects会决定是update还是mount
  //TODO: 根据current进行复用渲染，可以使用diff算法
  function ChildReconciler(shouldTrackEffects) {
      //闭包策略
      //目前 child可能的type ReactElement    string | number
      //渲染组件
      function reconcilerSingleElement(returnFiber, currentFirstChild, element) {
          const fiber = createFiberWithReactElement(element);
          fiber.return = returnFiber; //绑定好
          return fiber;
      }
      //渲染纯文字
      function reconcilerSingleTextNode(returnFiber, currentFirstChild, textContent) {
          const fiber = new FiberNode(HostText, {
              content: textContent,
          }, null);
          fiber.return = returnFiber;
          return fiber;
      }
      //渲染多child
      function reconcilerMultiChildren(returnFiber, currentFiber, childArray) {
          //PS:  child有可能多种类型,这里也需要进行判断对不同的child进行处理
          const fiber = createFiberWithReactElement(childArray[0]);
          let siblingFiber = fiber;
          fiber.return = returnFiber;
          for (let index = 1; index < childArray.length; index++) {
              placeSingleChild(fiber);
              siblingFiber.sibling = createFiberWithReactElement(childArray[index]);
              siblingFiber = siblingFiber.sibling;
          }
          return fiber;
      }
      // plugin
      //mount时只会在rootFiber存在Placement effectTag
      function placeSingleChild(fiber) {
          //TODO :处理完后的plugin
          if (shouldTrackEffects && fiber.alternate == null) {
              fiber.flags |= Placement;
          }
          return fiber;
      }
      return function reconcileChildFibers(workInProgress, currentFiber, childElement) {
          //TODO 其他类型的实现
          console.log(childElement);
          if (typeof childElement == "object" &&
              childElement != null &&
              Array.isArray(childElement) == false) {
              console.log(childElement.$$typeof);
              if (childElement.$$typeof == REACT_ELEMENT_TYPE) {
                  return placeSingleChild(reconcilerSingleElement(workInProgress, currentFiber, childElement));
              }
              else {
                  {
                      console.error("未实现的reconciler类型");
                      return null;
                  }
              }
          }
          if (typeof childElement == "string" || typeof childElement == "number") {
              return placeSingleChild(reconcilerSingleTextNode(workInProgress, currentFiber, childElement));
          }
          if (typeof childElement == "object" && Array.isArray(childElement)) {
              if (childElement.length == 0) {
                  return null;
              }
              return placeSingleChild(reconcilerMultiChildren(workInProgress, currentFiber, childElement));
          }
          {
              console.error("未知的childElement类型", childElement);
          }
          return null;
      };
  }
  const mountReconcilerChild = ChildReconciler(false);
  const updateReconcilerChild = ChildReconciler(true);

  //Diff算法会比较ReactElement来构造本次的fiber，并打上flag，具体的应该在completework执行
  //begin的所有阶段请参考https://kasong.gitee.io/just-react/process/beginWork.html#effecttag
  const beginWork = (wip) => {
      //初始化等
      //1.判断是否可以复用，待实现
      //2.根据tag区分要如何处理
      switch (wip.tag) {
          case FunctionComponent:
              return updateClassComponent();
          case ClassComponent:
              return updateFunctionComponent();
          case HostRoot:
              return updateHostRoot(wip);
          case HostComponent:
              return updateHostComponent(wip);
          default:
              {
                  console.error("beginWork: 没有与之匹配的tag");
              }
              break;
      }
      //最后要返回子节点
      console.log(wip.child);
      return null;
  };
  /**
   * 在React的Fiber架构中，updateQueue主要用于存储组件状态的更新。当你在一个类组件或函数组件中调用setState或forceUpdate时，
   * React会创建一个更新（Update）并将它添加到updateQueue中。
   * 然而，HostComponent是代表真实DOM元素的Fiber节点，它们不具有自己的状态。
   * 因此，HostComponent节点没有updateQueue，也就不需要处理updateQueue
   */
  function updateFunctionComponent(wip) {
      return null;
  }
  function updateClassComponent(wip) {
      return null;
  }
  function updateHostRoot(wip) {
      //采用reducer策略
      const memorizeState = wip.memorizedState;
      //每一个更新都涉及到Element的更新
      const update = wip.updateQueue;
      const pending = update.share.pending;
      update.share.pending = null;
      const { memorized: updateState } = processUpdateQueue(memorizeState, pending);
      wip.memorizedState = updateState;
      //获取下一个Element，准备转化为Fiber
      const nextChild = wip.memorizedState;
      reconcilerChildren(wip, nextChild);
      //准备更新
      console.log(wip.child);
      // return wip.child;
  }
  function updateHostComponent(wip) {
      //区分好！！！别弄混
      //wip.child 是子fiber 他的子ReactElement在props上面的child , jsx转化的时候就这么处理
      const nextProps = wip.pendingProps;
      const nextChild = nextProps.children;
      reconcilerChildren(wip, nextChild);
      return wip.child;
  }
  //构建child 子fiber节点
  function reconcilerChildren(wip, children) {
      const current = wip.alternate;
      //把ReactElement转化为Fiber并绑定到wip上
      if (current != null) {
          //update机制
          wip.child = updateReconcilerChild(wip, current.child, children);
      }
      else {
          // mount机制
          wip.child = mountReconcilerChild(wip, null, children);
      }
  }

  //请参考https://kasong.gitee.io/just-react/process/fiber.html#fiber%E7%9A%84%E7%BB%93%E6%9E%84
  //React 采用DFS来遍历构成Fiber树，
  //reconclier的render阶段会根据fiberNode构建子Fiber
  //beginWork为DFS的递阶段 ，completework为DFS的归阶段
  const createFiberWithReactElement = (reactElement) => {
      const { type, props, key, ref } = reactElement;
      const fiber = new FiberNode(HostComponent, props, key);
      if (typeof type === "string") {
          fiber.tag = HostComponent;
      }
      else if (typeof type === "function") {
          fiber.tag = FunctionComponent;
      }
      else {
          {
              console.error("未知定义的type类型", reactElement);
          }
      }
      fiber.type = type;
      fiber.key = key;
      fiber.ref = ref;
      return fiber;
  };
  function performUnitOfWork(fiber) {
      console.log(fiber);
      //DFS分为三步，先递，再归
      //next 子节点， fiber当前节点
      //next 会一直往下找 直到为null ，然后网上弹，如果有sibling，workInprogress为子节点，又走递归
      //设计思想：1.先一直往下走
      const next = beginWork(fiber);
      //Q:为什么要这样设计？
      fiber.memorizedProps = fiber.pendingProps;
      if (next == null) {
          return;
      }
  }
  //https://react.iamkasong.com/renderer/beforeMutation.html#%E6%A6%82%E8%A7%88

  var reactReconciler = {
      createFiberWithReactElement,
      performUnitOfWork
  };

  //打包后成为react包，导出createReactElement 即 React.createReactElement ,
  //babel 会吧jsx 转换 例如<div>aaa</div> 为React.createReactElement("div",{},"aaa")
  //通过我们自定义的方法就可以生成ReactElement
  var index = {
      version: "0.0.0",
      createElement: jsxDEV,
      createFiberWithReactElement,
      reactReconciler
  };

  return index;

}));
